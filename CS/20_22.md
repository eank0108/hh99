## 20. 이진검색

정렬 되어 있는 정보를 계속해서 두 그룹으로 나누어 확인,비교 단계를 거처가는 검색  
시간복잡도는 logN 이 됨.  [참고자료](https://developercc.tistory.com/1)
![image](https://user-images.githubusercontent.com/82391607/169180137-ddf70220-adf0-440a-9f64-889066810808.png)

예를 들면 1024개(2의 10승) 의 정렬되어 있는 배열에서 한가지 숫자를 찾으면 최대 10번만 비교 하면 됨.(숫자야구 또는 업다운 게임)
(선형 시간 알고리즘일 경우 최대 1024번 비교해야함, 1~1024, 시간복잡도 N)  [참고자료](https://yoongrammer.tistory.com/75?category=987044)
최악의 경우  
1~1024 중 가운데 값인 512 를 부름 => 다운  
1~ 512 중 가운데 값인 256 을 부름 => 다운  
1~ 256 중 가운데 값인 128 을 부름 => 다운  
1~ 128 중 가운데 값인 64  를 부름 => 업  
64~ 128 중 가운데 값인 96  을 부름 => 업  
96 ~128 중 가운데 값인 112 를 부름 => 다운  
96 ~ 112 중 가운데 값인 104 를 부름 => 다운  
96 ~ 104 중 가운데 값인 100 을 부름 => 다운  
96 ~ 100 중 가운데 값인 98을 부름 => 다운  
96 업이고 98 다운 이므로 정답은 97
```java
//while문 활용

//재귀함수
```
이진검색은 수행해야 하는 일의 양이 데이터의 양이 증가하는 것에 비해 천천히 증가함  
![image](https://user-images.githubusercontent.com/82391607/169180484-9284b304-818d-4273-a55c-0cc4ef845c94.png)
[참고자료](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=foat3376&logNo=70172946882)

## 선택정렬
최악의 경우  
[3,2,1]  
[1,2,3]  




## 이진검색
 - 시간 복잡도
 - 분할 정복
 - 점근적 척도
## 선택 정렬

## 퀵 정렬

## 