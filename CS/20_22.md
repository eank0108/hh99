## 시간복잡도
[참고](https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/)
- 입력값과 문제를 해결하는데 걸리는 시간과의 상관관계
- 알고리즘의 시간복잡도는 주로 빅-오 표기법을 사용하여 나타내며, 이 빅-오 표기법은 계수와 낮은 차수의 항을 제외시키는 방법 (점근적 척도)

- 5n^3 + 3n => O(n^3)
```java
class Algorithm{
    public void algorithm(n) {
        for (int i = 0; i < n; i++) {
            // n번 실행, O(n)
        }
    }
    public void algorithm2(n) {
        for (int i = 0; i < 2*n; i++) {
            // 2n번 실행, O(n)
        }
    }
    public void algorithm3(n) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // n^2 번 실행 O(n^2)
            }
        }
    }
    public int fibonacci(n) {
        // n번째 피보나치 수열을 리턴하는 함수
        if (n <= 1) return 1;
        return fibonacci(n - 1) + fibonacci(n - 2);
        // 함수 안에 2개의 재귀함수가 있으므로 O(2^N) 의 시간 복잡도를 가진다
    }
}
```
![image](https://user-images.githubusercontent.com/82391607/169797275-224b286c-26b9-4952-9996-7b04882b4d76.png)
## 20. 이진검색

- 분할 정복  
  여러 알고리즘의 기본이 되는 해결방법으로, 기본적으로는 엄청나게 크고 방대한 문제를 조금씩 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 다음 그것들을 다시 합쳐서 해결하자는 개념  
  ![image](https://user-images.githubusercontent.com/82391607/169741142-b665174f-8a3f-440a-aedb-f45058efc7c9.png)
  [참고](https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

- 이진검색  
  정렬 되어 있는 정보를 계속해서 두 그룹으로 나누어 확인,비교 단계를 거처가는 검색  
  시간복잡도는 logN 이 됨.



```java
class Algorithm{
    public int binarySearch(int n){
        // arr 안의 n 인덱스를 구하는 함수
        int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        int low = 0;
        int high = arr.length-1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (n == arr[mid]) {
                // n이 mid 인덱스 값과 일치하면 mid 반환
                return mid;
            } else if (n < arr[mid]) {
                // n이 mid 인덱스 값보다 작으면 high 를 mid-1로 변경
                high = mid - 1;
            } else if (n > arr[mid]) {
              // n이 mid 인덱스 값보다 크면 low 를 mid+1로 변경
                low = mid + 1;
            }
        }
        return -1; // 탐색 실패
    }
}
```
이진검색은 수행해야 하는 일의 양이 데이터의 양이 증가하는 것에 비해 천천히 증가함  
![image](https://user-images.githubusercontent.com/82391607/169180484-9284b304-818d-4273-a55c-0cc4ef845c94.png)


## 선택정렬
1. 주어진 배열 중에서 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
4. 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.

![image](https://blog.kakaocdn.net/dn/bekAxf/btqBWrh1Sjl/AAVyKUtExiy6pdwfbhgR3k/img.gif)
```java
public class Selection_Sort {
	private static void selection_sort(int[] a) {
		// a 배열의 값을 오름차순으로 정렬하는 함수
		for(int i = 0; i < a.length; i++) {
			int min_index = i; // 비교 대상 인덱스
			for(int j = i + 1; j < a.length; j++) {
                // 최소값을 갖고있는 인덱스 찾기 
				if(a[j] < a[min_index]) {
					min_index = j;
				}
			}	
			// i번째(비교대상) 값과 찾은 최소값을 서로 교환
            int temp = a[i];
            a[i] = a[min_index];
            a[min_index] = temp;
		}
	}
}
```
- 시간복잡도  
  (N-1) + (N-2)+ ... + 2 + 1  
  => (N^2-N)/2  
  => O(N^2) 의 시간복잡도를 갖는다.

- 장단점
    - 구현이 간단
    - 많은 메모리 공간이 필요하지 않음 (제자리 정렬)
    - 시간복잡도가 O(N^2) 으로 비효율적
    - 불안정 정렬  
      중복되는 값이 입력 순서와 동일하지 않게 정렬됨

  ![image](https://user-images.githubusercontent.com/82391607/169750376-a2b1f9ef-ce3e-44e9-b818-25f71ad7417f.png)

## 퀵 정렬
[퀵정렬 그림 자료](https://st-lab.tistory.com/250)
1. 피벗(기준값) 을 하나 선택한다.

2. 피벗을 기준으로 양쪽에서 피벗보다 큰 값, 혹은 작은 값을 찾는다. 왼쪽에서부터는 피벗보다 큰 값을 찾고, 오른쪽에서부터는 피벗보다 작은 값을 찾는다.

3. 양 방향에서 찾은 두 원소를 교환한다.

4. 왼쪽에서 탐색하는 위치와 오른쪽에서 탐색하는 위치가 엇갈리지 않을 때 까지 2번으로 돌아가 위 과정을 반복한다.

5. 엇갈린 기점을 기준으로 두 개의 부분리스트로 나누어 1번으로 돌아가 해당 부분리스트의 길이가 1이 아닐 때 까지 1번 과정을 반복한다. (Divide : 분할)

6. 인접한 부분리스트끼리 합친다. (Conqure : 정복)

퀵 정렬의 경우 피벗을 어느 곳을 기준으로 잡을 것인지에 따라 구현 방식이 다름  
![image](https://blog.kakaocdn.net/dn/bb5JKi/btq5aAjJZnz/lkkjHB9nXbzXkFG0cDUEK0/img.gif)


```java
class Sort{
  private static void r_pivot_sort(int[] a, int lo, int hi) {

    /*
     *  lo가 hi보다 크거나 같다면 정렬 할 원소가
     *  1개 이하이므로 정렬하지 않고 return한다.
     */
    if(lo >= hi) {
      return;
    }

    int pivot = partition(a, lo, hi);

    r_pivot_sort(a, lo, pivot - 1);
    r_pivot_sort(a, pivot + 1, hi);
  }
  private static int partition(int[] a, int left, int right) {

    int lo = left;
    int hi = right;
    int pivot = a[right];		// 부분리스트의 오른쪽 요소를 피벗으로 설정

    // lo가 hi보다 작을 때 까지만 반복한다.
    while(lo < hi) {

      /*
       * hi가 lo보다 크면서, lo의 요소가 pivot보다 큰 원소를
       * 찾을 떄 까지 lo를 증가시킨다.
       */
      while(a[lo] < pivot && lo < hi) {
        lo++;
      }

      /*
       * hi가 lo보다 크면서, hi의 요소가 pivot보다 작거나 같은 원소를
       * 찾을 떄 까지 hi를 감소시킨다.
       */
      while(a[hi] >= pivot && lo < hi) {
        hi--;
      }


      // 교환 될 두 요소를 찾았으면 두 요소를 바꾼다.
      swap(a, lo, hi);
    }


    /*
     *  마지막으로 맨 처음 pivot으로 설정했던 위치(a[right])의 원소와
     *  hi가 가리키는 원소를 바꾼다.
     */
    swap(a, right, hi);

    // 두 요소가 교환되었다면 피벗이었던 요소는 hi에 위치하므로 hi를 반환한다.
    return hi;
  }
  private static void swap(int[] a, int i, int j) {
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
  }
}

```

- 시간복잡도
    - 최선의 경우
      ![image](https://user-images.githubusercontent.com/82391607/169754351-0f7d777c-e3a6-4363-9069-530697fc632e.png)
      한 과정당 비교횟수는 N 이고 logN의 과정이 있으니 시간복잡도는 NlogN
    - 최악의 경우
      ![image](https://user-images.githubusercontent.com/82391607/169754736-0c54bedc-377d-4156-995f-ec0cc872230a.png)  
      리스트가 계속 불균형하게 나누어 지는 경우  
      한 과정당 비교횟수는 N 이고 N 의 과정이 있으니 시간복잡도는 N^2
    - 평균 시간 복잡도 O(NlogN) [[참고자료]](https://codingdog.tistory.com/entry/%ED%80%B5-%EC%A0%95%EB%A0%AC-%ED%8F%89%EA%B7%A0-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%99%9C-Onlogn%EC%9D%BC%EA%B9%8C) [[평균복잡도]](https://johngrib.github.io/wiki/average-complexity/)

## 여행하는 외판원 문제
[[P vs NP]](https://gazelle-and-cs.tistory.com/64)
- 다항 시간(Polynomial time): 시간복잡도가 N의 다항식으로 표현 된다면 이 알고리즘이 다항 시간에 동작한다고 말함
- 결정론적 알고리즘 : 동일한 값을 입력하면 매번 같은 값을 출력함
- 비결정론적 알고리즘 : 동일한 값을 입력해도 다른 결과를 출력할 수 있음, 각 계산 단계마다 컴퓨터가 '가지치기'를 해서 각각 병렬적으로 계산을 한다고 상상하면 됨

- P(Polynomial time): 결정론적 튜링 기계를 사용해서 다항 시간 내에 답을 구할 수 있는 문제의 집합

- NP(Nondeterminism Polynomial time): 비결정론적 튜링 기계를 사용해서 다항 시간 내에 답을 구할 수 있는 문제의 집합
- NP 문제를 해결하는 법은 다음 노드를 가르킬수 있는 힌트가 있거나, 문제를 병렬적으로 처리하는 방법이 있음
  ![image](https://upload.wikimedia.org/wikipedia/commons/thumb/1/16/Difference_between_deterministic_and_Nondeterministic.svg/1280px-Difference_between_deterministic_and_Nondeterministic.svg.png)
- NP문제 중에서도 답을 다항 시간 안에 찾을 수 있으면 그 문제를 P문제 라고 한다. 그래서 P는 NP의 부분집합이 된다.

![image](https://user-images.githubusercontent.com/82391607/169928024-bee29175-46cc-4c7c-a9b5-bc705751220d.png)
![image](https://user-images.githubusercontent.com/82391607/169928300-4b8bbbbf-ffa0-4538-834d-767296271354.png)
![image](https://user-images.githubusercontent.com/82391607/169928481-6cbac92a-960c-4c0b-b109-f1adb5c3895a.png)
![image](https://user-images.githubusercontent.com/82391607/169928547-9293fa87-6cfe-4a8a-9ad4-e3861c4e6c06.png)


- 
